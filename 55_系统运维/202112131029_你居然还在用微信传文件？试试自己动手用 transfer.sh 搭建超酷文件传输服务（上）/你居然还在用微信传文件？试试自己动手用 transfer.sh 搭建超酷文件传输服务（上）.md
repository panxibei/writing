你居然还在用微信传文件？试试自己动手用 transfer.sh 搭建超酷文件传输服务（上）

副标题：一个简单却很花式的文件传输方案 transfer.sh ~

英文：still-sending-files-through-wechat-try-using-transfersh-to-build-cool-file-sharing-service-1

关键字：transfer.sh,go,golang,文件共享,curl,wget,sharing



问一个问题，怎么将文件传给别人？

这还不简单，用微信啊！不行用 `QQ` 啊！再不行那邮件也可以啊！

好了好了，要是再这么说就暴露水平了，哈哈！

其实文件传输完全可以变得更优雅更酷炫的哦！



这次我就要给小伙伴们介绍一款文件传输分享服务 `transfer.sh` 。

它由 `golang` 开发，支持多个操作系统平台，可以带给我们全新的文件传输体验的解决方案。

她的特点是，简单、快速，通过命令行的方式传输文件，并且可以提供加密保护、无限上传下载、链接式分享等诸多牛叉功能。

花式上传正是 `transfer.sh` 最先引起我兴趣的特点之一，还没有接触过 `transfer.sh` 的小伙伴建议先参考阅读一下以前的文章。



> 前文参考：
>
> 文章链接：



好了，`transfer.sh` 很好玩，但最最最重要的是，它还可以作为单独的实例为我们提供我们自己的文件服务系统。

意思就是说，我们可以用她来建立自己的文件分享系统，这样我们就可以更加安全更加自由地与他人传递文件了。

本文将重点给大家分享如何搭建一个属于自己的 `transfer.sh` ，在此期间我再穿插一些使用的方式方法，以加深对 `transfer.sh` 服务运用的理解。



### 安装 `transfer.sh` 服务

由于 `transfer.sh` 支持跨平台，因此我们就用 `Windows` 来做演示，这样让小伙伴们也更加容易理解，至于 `Linux` 或 `BSD` 甚至是安卓等系统基本上是大同小异的。

打开 `Github` 上的项目页面，找到 `Release` 并下载相应的安装包。

> https://www.github.com/dutchcoders/transfer.sh/

图01



如果你的网速不错，也可以直接下载 `exe` 文件，我们下载的压缩包解压后其实也是得到一样的 `exe` 文件。

下载完成后，将其中的 `transfersh-v1.3.0-windows-amd64.exe` 这个文件释放出来，放到一个指定的文件夹中，比如我这边是 `C:\sysadm` 。

图02

图03



我们打开命令提示符，输入以下命令可以得到帮助信息。

```
C:\sysadm\transfersh-v1.3.0-windows-amd64.exe -h
```

图04



这些帮助信息作为参考，等一会儿就会用到，不用担心这么多的参数，实际使用会根据应用场景而并不需要涉及太多。

另外如果你觉得这个文件名太长了点，那你可以将它重命名为 `transfersh.exe` 这样的较短的名字。

当然，作为演示我后面都还会沿用原始的较长的文件名。



### 启动 `transfer.sh` 服务

在启动服务之前，我们需要先建立一个文件夹，用于映射内部服务的暂存目录。

比如，在 `C` 盘根目录下新建一个文件夹 `tmp` 。

```
mkdir C:\tmp
```



然后按照以下参数启动服务， `^` 用于书写代码时不中断命令的换行，你也可以将 `^` 去掉而写成一行。

```
transfersh-v1.3.0-windows-amd64.exe ^
	--provider=local ^
	--listener :80 ^
	--temp-path=/tmp/ ^
	--basedir=C:\tmp\
```



参数解释如下：

* `--provider=local`

  实际临时文件存放到本地。

* `--listener :80`

  `transfer.sh` 服务开启 `80` 端口侦听。

* `--temp-path=/tmp/`

  `transfer.sh` 服务内部的临时文件夹为 `/tmp/` 。

* `--basedir=C:\tmp\`

  设定本地文件夹 `C:\tmp\` 与服务内部目录 `/tmp/` 相互映射，作为临时文件存放地。



注意，在命令执行前请务必确保服务器端口已在防火墙中开放。

好了，命令执行后服务就开始运行了。

图05



这个时候，我们打开浏览器，在地址栏内输入 `http://server_ip` 后回车。

我们会惊喜地发现，我们自己的 `transfer.sh` 服务器已经在正常运行中了。

图06



我们可以看到，虽然与官方首页长得挺像，但里面的命令参数或链接都变成了我们自己服务器的IP地址了。

当然如果我们使用域名方式访问服务器也是可以的，只要保证能够正常解析域名即可，那样的话我们看到的页面上就是服务器的域名了。

接下来我们就试一下，看看能不能拿来传输文件。



### 测试上传文件

假定当前目录中有一个文件 `hello.txt` ，输入以下命令，我们将这个文件上传到服务器。

```
curl --upload-file ./hello.txt http://server_ip/hello.txt
```

图07



从返回的结果中我们得到了一个下载链接，比如：

```
http://server_ip/5liLmu/hello.txt
```



我们回到服务端来看看有没有什么变化。

嘿，果不其然，在服务端指定的本地文件夹 `C:\tmp` 中新生成了一个 `5liLmu` 的文件夹。

并且这个文件夹的名字与我们刚才上传时生成的随机字符串一致。



好，我们再来看看文件上传之后到底是怎么存放的。

一共有两个文件，一个就是我们上传的文件，另一个是以 `metadata` 为后缀的元数据文件。

图08



让我们看看这个 `metadata` 里面到底是什么东东。

用记事本打开它，可以看到如下的内容。

```
{
	"ContentType":"text/plain; charset=utf-8",
	"Downloads":0,
	"MaxDownloads":-1,
	"MaxDate":"0001-01-01T00:00:00Z",
	"DeletionToken":"7vEDa9tajs8U"
}
```



这个格式有点眼熟啊，感觉就是个 `Json` 数据嘛！

当然了，实际上以上内容是写在一行的，为了大家查看方便直观稍稍换了行。

这个 `Json` 就是以 `key-value` 的形式保存的数据信息，那么具体各个 `key` 的意思我想小伙伴们大概也能猜出个一二来吧。

比如 `MaxDonloads` 它的值是 `-1` ，表示无限下载。

这里有一个比较有趣的 `key` ，就是那个 `DeletionToken` ，后面跟着一串奇怪的字符。

这个又是什么意思呢？



从字面意思我们也能猜出个八九不离十哈，就是删除令牌啊！

那么它正是用于删除我们上传文件的。



### 如何删除上传的文件

其实我们通过在命令中追加 `-H "X-Url-Delete"` 参数即可从客户端获取删除令牌。

```
# -I 用于查看返回信息
curl -I -H "X-Url-Delete" --upload-file ./hello.txt http://server_ip/hello.txt
```

图09



从图中的返回信息中我们就可以看到有那么一行带有删除令牌的信息。

没错，那最后一串奇怪的字符就是删除令牌了。

```
X-Url-Delete: http://server_ip/0czFd5/hello.txt/NcPETCcGExW2
```



然后，怎么删？

很简单，拿刚才的令牌信息，照搬下面的命令就行了。

```
curl -X DELETE http://server_ip/0czFd5/hello.txt/NcPETCcGExW2
```



如果加上参数 `-I` 则可以查看返回信息。

当然了，即便你不主动删除文件，它也会在 `336` 小时后自动删除。

图10



OK，成功删除文件！

我们回到服务端也能看到文件已经被成功删除了！

图11



即使打条命令就可以删除文件，官方在新版中也新开发了提供网页界面删除文件的功能。

如图我们只要先点击 `delete` 那个按钮，然后再输入删除令牌 `DeletionToken` 并按下确认 `confirm` 按钮就可以删除文件了。

图12



### 写在最后

到目前为止，我们已经可以搭建一个属于我们自己的 `transfer.sh` 文件传输服务了。

虽然基本的上传下载分享文件的功能已经初具规模，但是如果你想让她再强大一些、应用范围再广泛一些，那么可以接着关注下一篇文章。

在下一篇文章中，我将为小伙伴们分享介绍一些关于 `transfer.sh` 应用范围更加广阔的使用方法，包括如何以 `Docker` 容器形式运行服务、如何结合第三方云存储以及其他一些很有趣的内容。

请大家不要着急，我将马不停蹄、加快赶制，就请各位拭目以待吧！



**扫码关注@网管小贾，阅读更多**

网管小贾的博客 / www.sysadm.cc

