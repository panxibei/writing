示例数据库

副标题：示例数据库

英文：

关键字：





### 示例数据 `Sakila`

`Sakila` 数据库是一个很棒的标准化数据库，它模拟了一家 `DVD` 出租商店（那些年龄稍长的人应该知道那是什么）所需的所有可能的表和数据。

这个示例数据库被设计为具有如下一些很乃斯的功能：

* 多对多关系
* 数据表之间存在多条路径（例如，电影-库存-租金-支付与电影-库存-商店-客户-支付）可用于练习表关联 `Joins`
* 数据列的一致性命名
  * 主键被统一定义为 `[tablename]_[id]`
  * 如果可能，外键的调用方式与其引用的主键一样。这允许在系统支持的情况下使用 `JOIN .. USING` 语法
  * 关系表没有任何代理键但使用复合主键
  * 每个表都有一个 `last_update` 审计列
  * 有一个合理大小的生成数据集可用 



`Sakila` 提供了不止一种数据库系统平台的支持，常见的 `MySQL` 、 `SQL Server` 、 `Oracle` 等等都有。

对于手里有两种以上的数据库系统的小伙伴来说，这真的是灰常棒的工具啊（擦擦口水）！

你瞧，激动得我开始说起了普通发......

**（文末有 `Sakila` 示例数据库打包下载）**

图y01



### `SQL` 导入文件

即使有多个不同的数据库系统平台也不用担心，`Sakila` 完全提供了针对不同平台的 `SQL` 文件。

通常每种平台会有四个这样的文件，分别如下：

* `sakila-schema.sql` - 生成数据表（结构）
* `sakila-insert-data.sql` - 插入数据
* `sakila-delete-data.sql` - 删除数据
* `sakila-drop-objects.sql` - 删除数据表（结构）



你看，这些文件从其命名就可以看出，它们是一伙的，既体现了数据构架的顺序，又相辅相成、各司其职。

在实际使用中，我们也可以针对它们的职能分别灵活运用即可。

注意，在插入数据时，会因为SQL语句没有批量整合而导致导入速度非常缓慢，需要和小伙伴们提前打个招呼。

接下来我们简单地看看 `Sakila` 数据库长什么样子。



### `Sakila` 数据表展示

这个 `Sakila` 数据库包含了23个表。

拿几个主要的表举例吧。



`actor` - 演员

图s01



`address` - 地址

图s02



 `category` - 影片分类 

图s03



`city` - 城市

图s04



`country` - 国家

图s05



`customer` - 观影用户

图s06



`film` - 影片

图s07



`film_actor` - 影片演员关联表

图s08



`film_category` - 影片分类关联表

图s09



`file_text` - 影片描述

图s10



`inventory` - 库存

图s11



`payment` - 租赁付款

图s12



`rental` - 影片库存租赁

图s13



`staff` - 商店员工信息

图s14



`store` - 影片商店

图s15



### 数据表关联图 `ERD`

从前面的表结构我们多少能看出来，这个 `Sakila` 示例数据库是真心简单而又不失完整性，可以说既照顾到了易懂易用，但又不复杂繁琐。



有23张数据表也不算少了，虽然每张表的字段不算多复杂，但要在短时间内厘清各表之间的结构，我想怎么也得花上数个钟头吧！

其实大神早就帮我们准备好了一份 `Sakila` 示例数据库各表之间的关联图。

看看，就是下面这个样子。

图x01



被吓到了吗？

其实作为示例数据库，它总是要考虑到大多数使用数据库的场景嘛，因此多少肯定会有一些交叉关联的情况出现。

不过请放心，这款示例数据库已经精简得很多了，作为测试调试程序已经足够使用了。

好了，静下心来，慢慢学习吧！



### 查询测试

一旦示例数据库 `Sakila` 被导入到了系统中，那么我们就可以开始测试使用它了，比如做一些查询工作。

请注意啦，不同的数据库系统所支持的 `SQL` 语法可能差别非常大，需要认真区分。



比如，使用 `MySQL/PostgreSQL` 来查询**出演影片较多的演员**。

```
SELECT first_name, last_name, count(*) films
FROM actor AS a
JOIN film_actor AS fa USING (actor_id)
GROUP BY actor_id, first_name, last_name
ORDER BY films DESC
LIMIT 1;
```



所得出的结果：

```
first_name    last_name    films
--------------------------------
GINA          DEGENERES       42
```

图s16



再比如，查询全店累计收入是多少。

此处需特别注意，如果你使用的是 `MySQL 5.7` ，那么爱木骚瑞，这个版本是不支持 `OVER` 函数的，可以使用 `MySQL 8.0` 。

我在这儿浪费了半个多小时，希望小伙伴们不要在此上当浪费时间！

```
SELECT payment_date, amount, sum(amount) OVER (ORDER BY payment_date)
FROM (
  SELECT CAST(payment_date AS DATE) AS payment_date, SUM(amount) AS amount
  FROM payment
  GROUP BY CAST(payment_date AS DATE)
) p
ORDER BY payment_date;
```



所得出的结果：

```
payment_date       amount         sum
-------------------------------------
2005-05-24          29.92       29.92
2005-05-25         573.63      603.55
2005-05-26         754.26     1357.81
2005-05-27         685.33     2043.14
2005-05-28         804.04     2847.18
2005-05-29         648.46     3495.64
2005-05-30         628.42     4124.06
2005-05-31         700.37     4824.43
2005-06-14          57.84     4882.27
2005-06-15        1376.52     6258.79
2005-06-16        1349.76     7608.55
2005-06-17        1332.75     8941.30
...
```

图s17



### 尝试在其他平台上使用 `Sakila`

通常 `Sakila` 在 `MySQL/PostgreSQL` 上表现OK，但是其他数据库系统上也能用吗？

毕竟现在还是有不少地方使用的是微软的 `SQL Server` ，还有很多大型企业用的则是 `Oracle` 。

因此，我也尝试了一下在更多的系统平台上导入测试 `Sakila` 。



##### 首先，我们将目光转到 `SQL Server` 这边。

我们先开一个大大的窗口来新建查询。

图a01



亦或者直接选择文件打开。

图a03



同样在 `sql-server-sakila-db` 文件夹中也有四个 `SQL` 文件，我们将创建框架 `schema` 的文件加载上来。

```
sql-server-sakila-db\sql-server-sakila-schema.sql
```

图a02



点击执行按钮跑一下刚才加载的 `SQL` ，从结果来看似乎一切顺利！

图a04

图a05



名为 `sakila` 的数据库被成功创建。

图a06



接下来如法炮制，加载插入数据集的 `SQL` 文件。

```
sql-server-sakila-db\sql-server-sakila-insert-data.sql
```

图a07



当点击执行按钮后，我的心彻底地凉了！

图a08



乖乖！居然报了这么多的错！

然后就是一番搏斗了，请往下看。



简言之，就是有几个表中的字段类型似乎有些问题，从而导致表与表之间的外键关联也同样出错。

比如其中， `tinyint` 类型只能表示 `0~255` 范围内的整数，可从这个字段的字面意思上看呢， `manager_staff_id` 好像是工作管理人员的编号，难道工作人员最多只有255个？

哦，好像租碟的小店不太会有这么多的员工哈！

要是做大做强开连锁店呢？

这里似乎有作者改动过的痕迹，有点想不通为啥要在这儿将 `int` 变成 `tinyint` ，这里还牵扯到了索引并关联了其他表，好吧，干脆注释掉这些行试试吧！

**（文末有 `SQL Server` 修正版 `Sakila` 示例数据库下载）**

大体修改总结如下：



创建 `staff` 表语句。

大概第 `261` 行：

```
staff_id INT NOT NULL IDENTITY,
```

修改成

```
staff_id TINYINT NOT NULL IDENTITY,
```



创建表 `store` 语句中。

大概第 `289` 行：

```
manager_staff_id INT NOT NULL,
```

修改成

```
manager_staff_id TINYINT NOT NULL,
```



创建表 `payment` 语句中。

大概第 `313` 行：

```
staff_id INT NOT NULL,
```

修改成

```
staff_id TINYINT NOT NULL,
```



创建表 `rental` 语句中。

大概第 `340` 行：

```
staff_id INT NOT NULL,
```

修改成

```
staff_id TINYINT NOT NULL,
```



好了，应该就是这么多了吧，再导入试试看！

图a09



OK！这次没毛病了！

请小伙伴们注意，在反复尝试导入数据失败时，你可以使用 `Sakila` 自身提供的删除 `SQL` 语句文件，也可以自行动手清空删除数据。

前者方法与前面导入数据一样。



删除清空数据。

```
sql-server-sakila-db\sql-server-sakila-delete-data.sql
```

图c01



删除 `Sakila` 数据库。

```
sql-server-sakila-db\sql-server-sakila-drop-objects.sql
```

图d01



好了，既然有数据了，那我们就来测试一下 `SQL` 语句查询输出。

图e01



再试试复杂一些的官网示例语句，查询出演电影次数最多的演员。

官网示例语句是 `PgSQL` 语法的，我们稍稍修改一下看看。

```
SELECT TOP 1 first_name, last_name, count(*) films
FROM actor AS a
JOIN film_actor AS fa
ON fa.actor_id=a.actor_id
GROUP BY fa.actor_id, first_name, last_name
ORDER BY films DESC
```

图e03



再来查询一下，全店累计收入。

这个语句不用怎么修改直接就能用，毕竟要钱滴，比 `MySQL 5.7` 强多了。

```
SELECT payment_date, amount, sum(amount) OVER (ORDER BY payment_date) as sum
FROM (
  SELECT CAST(payment_date AS DATE) AS payment_date, SUM(amount) AS amount
  FROM payment
  GROUP BY CAST(payment_date AS DATE)
) p
ORDER BY payment_date;
```

图e04





##### 最后再来试试 `Oracle` 。

如何导入就不多说了，这里看看测试结果。

`Oracle` 并不支持 `limit` 语法，因此查询语句需要调整一下。

```
SELECT *
FROM (
	SELECT first_name, last_name, count(*) films
	FROM [模式].actor a
	JOIN [模式].film_actor USING (actor_id)
	GROUP BY actor_id, first_name, last_name
	ORDER BY films DESC
)
WHERE rownum = 1
```

图z01



再来查询一下，全店累计收入。

`SQL` 语句还是要改一改啊，我太难了！

这里有个坑，`Oracle` 好像 `Date` 类型总是表现为长日期，因此不得不改用类型转换。

```
SELECT payment_date, amount, SUM(amount) OVER(ORDER BY payment_date) AS SUM
FROM (
  SELECT to_date(to_char(payment_date, 'yyyy-mm-dd'),'yyyy-mm-dd') AS payment_date, SUM(amount) AS amount
  FROM [模式].PAYMENT a
  GROUP BY to_date(to_char(payment_date, 'yyyy-mm-dd'),'yyyy-mm-dd')
) p
ORDER BY payment_date;
```

图z02





### 写在最后

好了，前面我花了好几天的时间，将一些看得见和看不见的坑都踩了一踩，希望小伙伴们看到这些坑可以顺利地跳过去。

另外，大家可以直接去 `Github` 下载 `Sakila` 的源代码，不方便下载的也可以到我这儿搬走。

> https://github.com/jOOQ/sakila



**sakila-main.zip (5.25M)**

下载链接：

提取码：



**sql-server-sakila-db.7z (1.41M)**

下载链接：

提取码：



OK，截止到目前为止，我们试过了好几个数据库平台了，基本上都能很好地运用 `Sakila` 这个示例数据库。

除此之外，还有好几个系统我暂时没时间测试了，比如 `db2` 、 `sqlite` 等等，我猜多多少少也有小伙伴要用到的，还是有测试价值的，所以就当家庭作业，各位回去慢慢研究吧！

最后如果你觉得多多少少有所收获，回来再看的机会也不多，大家都这么忙是吧，哈哈，那么请顺手点一点，让这篇文章的样子更好看一点儿，谢谢！



**扫码关注@网管小贾，个人微信：sysadmcc**

网管小贾 / sysadm.cc