示例数据库

副标题：示例数据库

英文：

关键字：





示例数据 `Sakila`



`Sakila` 数据库是一个很棒的标准化数据库，它模拟了一家 `DVD` 出租商店（那些年龄稍长的人应该知道那是什么）所需的所有可能的表和数据。

这个示例数据库被设计为具有如下一些很乃斯的功能：

* 多对多关系
* 数据表之间存在多条路径（例如，电影-库存-租金-支付与电影-库存-商店-客户-支付）可用于练习表关联 `Joins`
* 数据列的一致性命名
  * 主键被统一定义为 `[tablename]_[id]`
  * 如果可能，外键的调用方式与其引用的主键一样。这允许在系统支持的情况下使用 `JOIN .. USING` 语法
  * 关系表没有任何代理键但使用复合主键
  * 每个表都有一个 `last_update` 审计列
  * 有一个合理大小的生成数据集可用 



SQL导入文件

通常会有四个这样的文件，分别如下：

* `sakila-schema.sql` - 生成数据表（结构）
* `sakila-insert-data.sql` - 插入数据
* `sakila-delete-data.sql` - 删除数据
* `sakila-drop-objects.sql` - 删除数据表（结构）



你看，这些文件从其命名就可以看出，它们是一伙的，既体现了数据构架的顺序，又相辅相成、各司其职。

在实际使用中，我们也可以针对它们的职能分别灵活运用即可。

注意，在插入数据时，会因为SQL语句没有批量整合而导致导入速度非常缓慢，需要和小伙伴们提前打个招呼。

接下来我们简单地看看 `Sakila` 数据库长什么样子。



### `Sakila` 数据表展示

这个 `Sakila` 数据库包含了23个表。

拿几个主要的表举例吧。



`actor` - 演员

图s01



`address` - 地址

图s02



 `category` - 影片分类 

图s03



`city` - 城市

图s04



`country` - 国家

图s05



`customer` - 观影用户

图s06



`film` - 影片

图s07



`film_actor` - 影片演员关联表

图s08



`film_category` - 影片分类关联表

图s09



`file_text` - 影片描述

图s10



`inventory` - 库存

图s11



`payment` - 租赁付款

图s12



`rental` - 影片库存租赁

图s13



`staff` - 商店员工信息

图s14



`store` - 影片商店

图s15



### 数据表关联图 `ERD`

从前面的表结构我们多少能看出来，这个 `Sakila` 示例数据库是真心简单而又不失完整性，可以说既照顾到了易懂易用，但又不复杂繁琐。



有23张数据表也不算少了，虽然每张表的字段不算多复杂，但要在短时间内厘清各表之间的结构，我想怎么也得花上数个钟头吧！

其实大神早就帮我们准备好了一份 `Sakila` 示例数据库各表之间的关联图。

看看，就是下面这个样子。

图x01



被吓到了吗？

其实作为示例数据库，它总是要考虑到大多数使用数据库的场景嘛，因此多少肯定会有一些交叉关联的情况出现。

不过请放心，这款示例数据库已经精简得很多了，作为测试调试程序已经足够使用了。

好了，静下心来，慢慢学习吧！



### 查询测试

一旦示例数据库 `Sakila` 被导入到了系统中，那么我们就可以开始测试使用它了，比如做一些查询工作。

请注意啦，不同的数据库系统所支持的 `SQL` 语法可能差别非常大，需要认真区分。



比如使用 `MySQL/PostgreSQL` 来查询出演影片较多的演员。

```
SELECT first_name, last_name, count(*) films
FROM actor AS a
JOIN film_actor AS fa USING (actor_id)
GROUP BY actor_id, first_name, last_name
ORDER BY films DESC
LIMIT 1;
```



所得出的结果：

```
first_name    last_name    films
--------------------------------
GINA          DEGENERES       42
```



图s16











`tinyint` 类型只能表示 `0~255` 范围内的整数，可从这个字段的字面意思上看， `manager_staff_id` 好像是工作管理人员的编号，难道工作人员最多只有255个？

有点想不通为啥要在这儿将 `int` 变成 `tinyint` ，这里还牵扯到了索引并关联了其他表，好吧，干脆注释掉这一行试试吧！



创建 `staff` 表语句

大概第 `261` 行

```
staff_id INT NOT NULL IDENTITY,
```

修改成

```
staff_id TINYINT NOT NULL IDENTITY,
```



创建表 `store` 语句中

大概第 `289` 行

```
manager_staff_id INT NOT NULL,
```

修改成

```
manager_staff_id TINYINT NOT NULL,
```



创建表 `payment` 语句中

大概第 `313` 行

```
staff_id INT NOT NULL,
```

修改成

```
staff_id TINYINT NOT NULL,
```



创建表 `rental` 语句中

大概第 `340` 行

```
staff_id INT NOT NULL,
```

修改成

```
staff_id TINYINT NOT NULL,
```





测试 `SQL` 语句

图e01



再试试复杂一些的官网的示例语句

出演电影次数最多的演员（）

图e02



官网示例语句是 `PgSQL` 语法的，我们稍稍修改一下看看。

```
SELECT TOP 1 first_name, last_name, count(*) films
FROM actor AS a
JOIN film_actor AS fa
ON fa.actor_id=a.actor_id
GROUP BY fa.actor_id, first_name, last_name
ORDER BY films DESC
```

图e03









全店累计收入

图e05



这个语句不用怎么修改直接就能用。

```
SELECT payment_date, amount, sum(amount) OVER (ORDER BY payment_date) as sum
FROM (
  SELECT CAST(payment_date AS DATE) AS payment_date, SUM(amount) AS amount
  FROM payment
  GROUP BY CAST(payment_date AS DATE)
) p
ORDER BY payment_date;
```

图e04

