十六进制的时间格式到底是个什么鬼？

副标题：





##### 最近打开文档的访问日期时间

这个访问日期时间是个很重要的因素，作为查找线索，时间总是不可或缺的。

在前面讲到的注册表项 `File MRU` 中，按顺序读取 `Item + 数字序列` 形式的键值即可。

其中包含了我所要的全部信息，类似于如下：

```
[F00000000][T01D6E0414E7254A0][O00000000]*C:\Users\Admin\Desktop\abc.xlsx
```



这些键值中有文件路径及文件名，更重要的是还有访问日期和时间。

但令我有些沮丧的是，这个以字母 `T` 开头的日期字符串却并不好转换成人类可直观的通用格式。

这到底是个什么时间格式啊？！



网上都是说关于如何清除访问记录，却几乎没有说如何解析这段字符串信息，T字开头的时间格式的说明更是无从谈起。

我前前前后后花了两三天的时间，也才粗略地弄懂了很多遥不可及高大上的知识概念。

首先， `T01D6E0414E7254A0` 这个时间格式看上去应该是个十六进制的数字，一共8位。



我尝试了网上的在线时间转换程序，可惜找不到这种格式的合理解释，即使把它转换成十进制也无济于事。

看样子，它并不是一个普通的Unix时间戳，所以普通的转换方式并不适用。



然后，我找了这样一段老外的文章。

> As Harlan mentioned in his previous post, each Item # value in the File and Place MRU subkeys should contain data similar to “[F00000000][T01CF2DF40FEB4220][O00000000]*Z:FilesPresentation1.pptx”, with the value in the second set of brackets being a FILETIME structure that corresponds to the last time the file or directory was accessed from the application.  

哦，原来它是一种 `FILETIME` 结构的时间格式啊！

好吧，那就去找关于 `FILETIME` 相关的API函数，看看有没有转换代码参考。

接着我又在网上搜索关于时间转换的API函数，寄希望于程序自身，看是否有可能通过程序自己来做转换。

找到了一些代码。

```vb
Public Type FILETIME
       dwLowDateTime As Long
       dwHighDateTime As Long
End Type

Public Type SYSTEMTIME
       wYear As Integer
       wMonth As Integer
       wDayOfWeek As Integer
       wDay As Integer
       wHour As Integer
       wMinute As Integer
       wSecond As Integer
       wMilliseconds As Integer
End Type

Private Declare Function FileTimeToSystemTime Lib "kernel32" (lpFileTime As FILETIME, lpSystemTime As SYSTEMTIME) As Long
Private Declare Function SystemTimeToVariantTime Lib "OLEAUT32.DLL" (lpSystemTime As SYSTEMTIME, vtime As Date) As Long
```

可是，非常可惜啊，这根本就不能用啊！

因为即使把十六进制转换成十进制，然后再使用API函数转换，结果根本就不对！

其实这里犯了个错误，这些转换函数是针对类似于 Unix 时间戳的，而并非针对现在的这种格式。

那这个奇怪的十六进制时间格式到底是个啥呢？

我再次陷入了怪圈。



好吧，再来！

又过了很久，我终于找到了老外的一段文字。

图13



看完后我真的是醍醐灌顶、茅塞顿开啊！

啊，原来这玩意是加密的啊，好像叫一个什么 `Dcode` 的数字检测工具可以识别它。

很容易我就找到了 `Dcode` ，也很容易地将它下载了下来。

这是一款免费时间格式解析程序，很棒，为作者点赞！

我赶紧用它尝试解析手里的奇怪时间格式，没想到居然成功了！

图14



我向成功迈出了坚实的第一步，心中充满了愉悦的心情。

其实在此之前，我还一段在纠缠十六进制内存存储大小尾端的问题，这个太复杂就不啰嗦了。

目前暂时得出的了一个结论，就是这个十六进制的时间格式，是一种大尾端存储的格式。

有的小伙伴就要问了，那这种格式要转换成人类能看得懂的格式，其算法是怎样的呢？



的确，这难倒了我，刚才的喜乐心情瞬间全无。

眼前只知道是这种时间格式，如何转换肯定不是网上通常的算法，再接着找找吧。

偶然间发现 `VB.net` 之类的语言好像自带有转换方法。

```vb
Dim date1 As Date = CDate("01/01/0001 00:00")
MessageBox.Show(date1.Ticks.ToString)
date3 = date1.AddTicks(&H1C89628FBFACC74)
MessageBox.Show(date3.ToLongDateString & " " & date3.ToLongTimeString)
```



这段代码对于我来说并无参考价值，更何况我用的是 `VB6` ，看样子 `VB6` 是没有现成的代码可供使用了。

无独有偶，在网上扒了半天，居然被我找到了一段用 `C++` 语言写的转换代码。

其中大佬写了这么一段话。

> In unix systems date/time is often (but not always) recorded as a 32-bit integer indicating seconds past since Epoch (00:00:00, Jan 1, 1970). But for *Windows 64-bit LE* format, it means "x100 nanoseconds past since `00:00:00.000,000,0 Jan 1, 1601`". Your hexadecimal number is a raw binary integer, so it can be easily interpreted by `scanf`.
> Here's a piece of stuff that I found from one of my oldest C programs. You can optimize it and add time zone support by yourself.

**简单讲就是在 Windows 64位大尾端格式下，这种时间格式是指距离 `1601-01-01 00:00:00` 的以100纳秒为单位的倍数。**

什么什么？能不能把话说清楚点？

还是举例吧：

我们拿到了一个奇怪的时间格式 `T01D6E0414E7254A0` 。

然后拿起你心爱的计算器，将它转成十进制，也就是 `132539810147620000` 。

再然后，将这个十进制数字乘以100，可以得到 `13253981014762000000` 。

这个数字的单位就是纳秒，但是可能你的计算机器容纳不了这么多的位数，计算时会出错，怎么办呢？

那我们就换个思路，将它直接计算成秒不就行了？

根据 `1秒 = 1000000000纳秒（9个零）` 这个公式，我们可以很清楚地知道， `100纳秒（2个零）` 的倍数可以将它除以 `10000000（7个零）` ，那么就很容易地得到单位是秒的数字啦。

所以我们最终得到 `132539810.14762` 秒！

也就是这个时间是指距离 `1601-01-01 00:00:00` 过去了 `132539810.14762` 秒，很显然，那个小数点后的数字是指微秒。



接下来的事情就变得简单多了，只需要计算前面得到的秒数，将它转成年、月、日、时、分、秒即可。

大佬也给出了参考代码。

```c++
#include <stdio.h>
int mDays[12]={31,28,31,30,31,30,31,31,30,31,30,31};
const int daySec = 86400;
int yearDays(int y){
    return 365 + (y%400==0 || (y%4==0 && y%100!=0));
    // Pre-Caesar calendar doesn't work well, don't add it
}
void win_u64tod(unsigned long long utime){
    int y=1601, d=0, mo=0, h=0, m=0, s=0, ms=0;
    ms = utime % 10000000;
    utime /= 10000000;

    while (utime >= daySec*yearDays(y)){
        utime -= daySec*yearDays(y);
        y ++;
    }
    if (yearDays(y) == 366) mDays[1]=29;
    d = utime / daySec;
    utime %= daySec;
    while (d >= mDays[mo]){
        d -= mDays[mo];
        mo ++;
    }
    h = utime/3600;
    utime %= 3600;
    m = utime/60;
    s = utime%60;
    printf("%4u-%2u-%2u %2u:%02u:%02u.%07u\n", y, 1+mo, 1+d, h, m, s, ms);
}

int main(){
    union{
        char c[8];
        unsigned long long ull;
    } a;
    int i;
    for (i = 0; i < 8; i ++){
        scanf("%2x", a.c + i);
    }
    win_u64tod(a.ull);
}
```



我用的是 `VB6` ，我将它“翻译”成了 `VB6` 的语法。

```vb
' 判断平年还是闰年
Public Function yearDays(ByVal y As Integer) As Integer
    On Error GoTo errorHandle
    If (y Mod 400) = 0 Or (y Mod 4) = 0 And (y Mod 100) <> 0 Then
        yearDays = 366
    Else
        yearDays = 365
    End If
    Exit Function
errorHandle:
    yearDays = 365
End Function

Public Function Filetime2Datetime(ByVal UTime As Currency, Optional Offset As Integer = 0) As String
    On Error GoTo errorHandle

    Dim mDays(12) As Integer
    mDays(0) = 31: mDays(1) = 28: mDays(2) = 31: mDays(3) = 30: mDays(4) = 31: mDays(5) = 30: mDays(6) = 31: mDays(7) = 31: mDays(8) = 30: mDays(9) = 31: mDays(10) = 30: mDays(11) = 31
    
    Dim daySec As Long
    daySec = 86400
    
    Dim y As Long, mo As Long, d As Long, h As Long, m As Long, s As Long, ms As Long
    y = 1601: mo = 0: d = 0: h = 0: m = 0: s = 0: ms = 0
    
    Do While UTime >= daySec * yearDays(y)
        UTime = UTime - daySec * yearDays(y)
        y = y + 1
    Loop
    
    If yearDays(y) = 366 Then mDays(1) = 29
    d = Int(UTime / daySec)
    UTime = UTime Mod daySec
    
    Do While d >= mDays(mo)
        d = d - mDays(mo)
        mo = mo + 1
    Loop
    mo = mo + 1
    d = d + 1
    
    h = Int(UTime / 3600) + Offset
    If h > 24 Then
        d = d + 1
        h = h - 24
    End If
    
    UTime = UTime Mod 3600
    m = Int(UTime / 60)
    s = UTime Mod 60
   
    Filetime2Datetime = Format(y & "-" & mo & "-" & d & " " & h & ":" & m & ":" & s, "yyyy-MM-dd hh:mm:ss")

    Exit Function
errorHandle:
    Filetime2Datetime = "1601-01-01 00:00:00"
End Function

' 调用，参数1：十进制数字，参数2：时区
Filetime2Datetime(132539810, 8)
```



