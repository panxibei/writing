LivePaper

副标题：

英文：

关键字：



最近一档综艺节目《一年一度喜剧大赛》正在热播，颇受时下年轻人的追捧。

这个节目很有特色，形式年轻化、多玩化，剧本也是脑洞频出、创意无限，收视率自然也是节节攀升。

其中有这么一部被创作者自称为陷阱喜剧的《先生请出山》在播出后突然就在网络上爆火了。

究其原由，主要是这部喜剧的结尾，三位主创也是表演者的魔性舞步。

要是你还没看过，那赶快去看一看！

记住，多看一会儿，保证让你成功洗脑，脑海里甩也甩不掉的魔性舞步和音乐。

怎么说着说着好像跑题了？

其实我也是这魔性舞步的“受害者”，脑海中挥之不去的走位步伐让我无法自拔，甚至到了如痴如醉的地步。

于是我想了一个办法，干脆将这魔性舞步视频当作动态桌面壁纸，有事没事地就欣赏欣赏！



漂亮的壁纸千千万，桌面设定也很简单，可是这视频的壁纸怎么整呢？

网上倒有不少提供动态桌面功能的程序，不过或多或少都有点小问题，比如夹带私货，又比如功能冗余。

看来只好自己动手了，工程量有点大啊！

好在元旦期间休息在家，花了几天的时间研究了一下，没想到就入了坑，摔成了0.5级伤残！

现在就将“工伤事故”汇报给小伙伴们，希望各位少走弯路啊！



实验平台：Windows 10 （默认开启 `Aero` ）





### 网上关于桌面壁纸原理的描述

在正式开始了解原理之前，我们需要先请出“窗口句柄抓取工具”：`Microsoft Spy++` 。

当然如果你对此比较熟悉，也是可以用其他一些窗口句柄查看工具的。

不过如果你不太清楚什么是窗口句柄，那也没关系，我简单给你解释一哈，你大概了解了就行，别担心其实我和你一样也是小白，不需要太专业的。

那为啥要用这个工具呢，另外什么是窗口句柄呢？



首先我们要知道，在系统中窗口（或叫作窗体）是最常用最基本的容器载体，在窗口中会有很多各种各样不同的控件，它们都是用来操作系统功能或与用户互动的。

窗口很重要，那么我们如何管理这些窗口呢？

很简单，系统会分配给这些窗口一个ID，这个ID就叫作句柄（Handle）。

这个句柄就像身份证号码一样，当我们想要操作这些窗口时，只要告诉系统它的身份证ID也就是窗口句柄就可以了。



而实际上我们的系统是由很多很多个窗口组成，有的看得见，有的看不见，有的看得见但无法直接访问，而有的即使看不见我们也可以对它进行操作，总之所有的这些窗口堆叠而成最后呈现在我们面前。

你只要把这些窗口想像成多块不同的玻璃，分别多层次地立在了你的面前，有的透明而有的不透明。

那么对于桌面来说，它也是算是一块玻璃（一个窗口），只是它有些特殊，里面还套着几个子窗口。

因此，大概地了解了窗口的概念，那么我们就可以使用 `Spy++` 来观察它到底是个什么模样了。

如下图，通过 `Spy++` 来展开当前窗口的句柄树，就可以非常容易地了解到桌面窗口里面是怎么套娃的。

图b01



```
|- "Program Manager" Progman	// 总体桌面
|--- "" SHELLDLL_DefView	// 负责显示桌面图标
|----- "FolderView" SysListView32	// 控制桌面图标排列顺序
|------- "" SysHeader32	// 隐藏窗口，功能不详
```



最顶上就是桌面窗口的句柄，它在下面有很多个子窗口。

其中重点的对于我们有用的就是名字叫作 `Program Manager` 的子窗口，它正是我们苦苦寻找的桌面背景，里面囊括了包含壁纸和图标的子窗口。

这些子窗口中的 `"" SHELLDLL_DefView` 就是桌面图标窗口了。

简单说一嘴，引号里是 `窗口标题` ，而后面则是 `类名` ，比如 `"Program Manager"` 就是窗口标题，而  `Progman` 就是类名了。

知道窗口标题和类名会非常有利于我们查找定位窗口。



根据前面的介绍，我们很容易得出一个结论，既然桌面壁纸和图标是分别属于不同的子窗口，那么是不是我们可以将自己的程序窗口插入它们之间，就可以实现在图标下方显示呢？

想法是没错，可经过我的实际测试，根本无法实现这样的效果！



将程序窗口设定为 `Progman` 的子窗口，虽然它跑到了所有窗口的最后面，但是却无法在图标后面显示。

图b03

图b02



那么问题出在哪儿呢？



原来啊，我们使用的是 Windows 10 系统，虽说它默认就支持 `Aero` 效果，但它还有一个多桌面的新功能，你只要按一下 `Win + Tab` 键就能看到了。

而这个多桌面功能会使得桌面窗口产生奇妙的变化，会由系统生成多个 `WorkerW` 的窗口出来。

而跑出来的这么多个 `WorkerW` 窗口中呢，有一个会把原来 `Progman` 下的子窗口给“抢过去”，就像下图那样。

图a02



好了，这么一来可坏事了！

我们按照 `Progman` 窗口来找到桌面图标背景的方法就彻底失效了！

那为啥搞出来这么多个 `WorkerW` 呢，就不能愉快地使用 `Progman` 吗？

实际上官方是这么解释的，为了让桌面切换呈现平滑过渡的效果，因此设计启用了多个 `WorkerW` 窗口，否则效果会糟糕到你想砸电脑了。

好吧，道理都懂，那接下来怎么整呢？

是不是我们就尝试寻找这个拥有 `SHELLDLL_DefView` 类子窗口的 `WorkerW` ，然后将自己程序的窗口作为子窗口放到它的后面就行了呢？



经过我又一番的折腾，发现即使找到了目标 `WorkerW` ，并且将程序窗口放到它在下面还是行不通。

如下图，程序窗口虽然跑到了所有窗口的最后面，但却还是停留在了桌面图标的前面，效果就跟前面将程序窗口挂在 `Progman` 下面是一样一样的。

图b04

图b02



这下我就懵了，怎么这也不行，那也不行呢？

实际上这里还有一个套路，这个套路着实让我琢磨了很久很久！

什么套路呢，咱们往下看！



我查阅了网上大量的资料，在不断的实验中我发现除了拥有子窗口的 `WorkerW` 之外，其他所有的 `WorkerW` 都是隐藏不可见的。

图b05



而实际有效的做法是，我们需要将程序窗口嵌入到第二个可见非隐藏的 `WorkerW` 之上才行。



##### 让 `WorkerW` 窗口可见并且变透明

前面我们说过，按下 `Win+Tab` 键可以切换多桌面，当我们这么一切换时，系统就会产生多个 `WorkerW` 窗口用于过渡切换效果。

所以我们可以用程序模拟按下 `Win+Tab` 键。

不过我尝试模拟按键后，发现有窗口闪动的现象，不是太理想的状态，于是我找到了网上的资料。



根据网上资料，Windows 有一个系统保留消息，当我们向 `Progman` 窗口发送 `0x052C` 消息时，桌面就会生成一个透明的 `WorkerW` 窗口，同时会将 `Progman` 的子窗口转移到这个新生成的 `WorkerW` 之下。

需要注意的是，这是在 `Vista` 之后的版本才有效，嗯，可以理解为开启 `Aero` 效果的系统。

```
lngDesktopHwnd = FindWindow("Progman", vbNullString)

' 发送 0x052C 使其产生 WorkerW
SendMessage lngDesktopHwnd, &H52C, 0, 0
```



##### 遍历查找目标 `WorkerW` 窗口

生成了我们想要的 `WorkerW` 窗口后，我们就要想办法去找到那个目标窗口，也就是第二个可见的 `WorkerW` 窗口。

切记，这个 `WokerW` 窗口是可见非隐藏的，并且同时不包含任何子窗口的。

```vb
' 获取桌面句柄
lngDesktopHwnd = GetDesktopWindow

' 获得第一个 WorkerW 窗口句柄
lngWorkerW = FindWindowEx(lngDesktopHwnd, 0, "WorkerW", vbNullString)

' 定义临时类名，用于对比查找多个同级的 WorkerW 窗口
Dim lpClassName As String

' 遍历所有 WorkerW 直至找到不拥有 SysListView32 子窗口的那个 WorkerW 为止！
Do While lngWorkerW > 0

	If IsWindowVisible(lngWorkerW) Then

		lngShellDll = FindWindowEx(lngWorkerW, 0, "SHELLDLL_DefView", vbNullString)

		If lngShellDll = 0 Then
			Exit Do
		Else
		
            ' 查找下一个同级的类窗体句柄
            lpClassName = Space(255)
            Do While UCase(Left(lpClassName, 7)) <> UCase("WorkerW")
                lngWorkerW = GetWindow(lngWorkerW, GW_HWNDNEXT)
                GetClassName lngWorkerW, lpClassName, 255
            Loop
    	End If

	Else
	
        ' 查找下一个同级的类窗体句柄
        lpClassName = Space(255)
        Do While UCase(Left(lpClassName, 7)) <> UCase("WorkerW")
            lngWorkerW = GetWindow(lngWorkerW, GW_HWNDNEXT)
            GetClassName lngWorkerW, lpClassName, 255
        Loop
    End If

Loop
```



##### 将程序窗口变成目标 `WorkerW` 窗口的子窗口

就像下图这样，我们的程序窗口跑到了第二个可见 `WorkerW` 的下面了。

图a01



参考代码如下：

```
' 将程序窗口设定为 WorkerW 的子窗口，WorkerW 成为父窗口
lngOriginalParentHwnd = SetParent(Me.hwnd, lngWorkerW)
    
' 最后在程序退出时别忘记再变回来
lngTmpHwnd = SetParent(Me.hwnd, lngOriginalParentHwnd)
```



最后，我们看到了这样的效果，窗口终于跑到了图标的后面。

图a03



### 效果演示

后续还有很多工作需要继续，比如播放器的操控，前景布局等等。

不过这些繁杂的事不算主要问题，我们只要基本能实现桌面动态播放视频即可。

就像下面，效果还算可以吧。







### 写在最后

前面也啰嗦了一大堆，反正不管怎么样吧，窗口已经实现在桌面图标后面显示了，之后的工作也就此继续展开。

比如在窗口上加上个播放器，然后再给它一些播放时的操作控制功能。

不过这里需要向小伙伴们解释一下的是，由于我也是个小白，查找资料连带测试花了我不少时间，因此做出来的最终效果可能无法和那些商业软件相比。

比如播放器，我为了节约时间就把系统默认自带的 `Windows Media Player` 拿来用，自然有时候它的播放效果并不是很好。

当然以后有时间的话，我是会改进这一问题，使用 `libVLC` 来做为播放引擎。

如果你们喜欢，尽管拿去拿去别客气！

但是哈，别忘记关注、点赞外加转发哦！

爱你们，么么哒~



**扫码关注@网管小贾，阅读更多**

网管小贾的博客 / www.sysadm.cc









1、判断操作系统版本
2、如果是Win7，则直接查找 progman 类，在
3、将程序窗体放到一个可见的、非隐藏的，并且是非SysListView32所在的WorkerW下。