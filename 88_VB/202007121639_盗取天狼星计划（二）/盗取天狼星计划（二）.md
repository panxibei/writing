盗取天狼星计划（二）

副标题：完美卧底~



叶冲双眉紧锁，目光凝视着前方，思索着白天的一切，生怕有哪个细节出错。

今天一大早他就来到了军政厅，发现所有的工作人员比之前更加忙碌。

而从佐藤将军办公室出来的机要秘书见了他也只是草草地打了个招呼，行色匆匆地走开了，叶冲顿时生起一丝不祥的预感，心思敏锐的他不由得警觉起来。

自从宫本那家伙在佐藤面前打小报告，作为当前香岛军政厅最高领导的佐藤也慢慢对叶冲起了疑心。

现在大小事情都交由宫本处理，而宫本连开会都不通知叶冲。

宫本似乎手里也拿着相似的文件夹，难道有什么计划行动吗？

叶冲被机要秘书通知去开会。

得知有一份绝密胡蜂计划，而这项计划是要暗杀我方爱国抗日人士。

暗杀名单只保存在佐藤一个人用的U盘中，每次只通过打印名单的方式交给行动队。

而U盘被藏在某个秘密地点，除了佐藤任何人都不知道在哪里。



事态紧急，查找U盘下落已不可能！

电脑里植入程序窃取名单，也行不通，因为很容易被发现。

思考再三，唯一的办法就是截获打印内容，叶冲决定拼一下。







#### 行动一：定位打印机

佐藤的办公室里不止有一台打印机，短时间内是无法确定他会使用哪一台打印行动计划的。

叶冲想到，必须要监视每一台他可能使用的打印机，才能成功地截获计划内容。

于是，他使用VB代码很快实现了列出所有打印机的功能。

```vb
' 引用 Microsoft WMI Scripting V1.2 Library
' 加载打印机列表
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
Set wmiObjSet = objWMIService.InstancesOf("Win32_Printer")

' 获取所有打印机名称
cboPrinters.Clear
For Each wmiObj In wmiObjSet
    cboPrinters.AddItem wmiObj.DeviceID
Next

Set wmiObj = Nothing
Set wmiObjSet = Nothing
Set objWMIService = Nothing
```







#### 行动二：寻找后台打印文件夹

叶冲闭上眼睛，努力在脑海中搜索着以前在电讯课中计算机相关的所学知识。

突然，他想到，系统通常会通过一个叫做 `Print Spooler` 的打印后台处理服务来管理所有本地和网络打印队列及控制所有打印工作。

而 `Print Spooler` 服务会把打印文档依次排队，并在打印的时候统一放在后台打印文件夹中存放。

嗯，一定要先找到这个文件夹的所在，然后才能对文档进行下一步处理。



为了寻找Windows10的后台打印文件夹，需要按以下步骤走。

1、依次点击 `开始菜单` > `设置` > `设备` 。

2、找到 `打印机和扫描仪` ，点击 `打印服务器属性` 。

图1

3、选择 `高级` 选项卡，可以看到 `后台打印文件夹` 实际路径。

Windows10的后台打印文件夹默认位于 `C:\Windows\System32\Spool\Printers` 。

图2

4、如果想要更改，可以点击按钮 `更改高级设置` 。



这个后台打印文件夹其实是所有打印机的默认设置。

当有多台不同的打印机时，也可以分别设置各自不同的后台打印文件夹。

方法很简单，只要修改相应打印机的注册表项即可。

```shell
# 比如打印名称为 Microsoft Print to PDF
# 修改 SpoolDirectory 键值为自定义文件夹，默认键值为空则指向C:\Windows\System32\Spool\Printers
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Printers\Microsoft Print to PDF]
"SpoolDirectory"=""
```

图3



注意事项：

1. `SpoolDirectory` 必须指定非根目录的实际目录路径，如果指定了根目录路径（如：`C:\`），那么系统自动恢复为默认设置（即 `C:\Windows\System32\Spool\Printers` ）。
2. 如果 `SpoolDirectory` 所在驱动器为NTFS文件系统，需要保证给予可访问的权限。



后台打印文件夹虽然找到了，可是叶冲想到，修改默认值一旦被人发现暴露的风险极高，况且修改的时间成本也太大。

思来想去，于是决定不做任何改动。



#### 行动三：设法保留打印的文档

叶冲想起当年学习计算机的知识点，意识到光有后台打印文件夹还不够，因为系统默认是不会保留打印过的文档的，必须让系统保留文档才有可能获取。

不过可以通过设定让系统暂时保留下打印文档，在获取文档内容之后再删除文档！

想法不错，那么怎么让系统可以保留打印文档呢？



依次打开 `控制面板` > `设备和打印机` ，右击需要设定的打印机后选择 `打印机属性` ，选择 `高级` 选项卡。

图4



可以看到，默认 `保留打印的文档` 一项是没有被勾选的。

怎么是灰色不可用状态呢？

其实是权限问题，选择 `常规` 选项卡，点击 `更改属性` 按钮后就可以勾选 `保留打印的文档` 了。

图5



这样的操作看上去简单，可是时间紧、任务重，还是要再快点为妙。

叶冲还是想到了VB代码。

```vb
' 使用WMI遍历打印机属性来设定是否保留打印文档
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
Set wmiObjSet = objWMIService.InstancesOf("Win32_Printer")

For Each wmiObj In wmiObjSet
    If wmiObj.DeviceID = lstPrintersSelected.List(lstPrintersSelected.ListIndex) Then

        If chkSaveDocument.Value = vbUnchecked Then
            wmiObj.KeepPrintedJobs = False
        Else
            wmiObj.KeepPrintedJobs = True
        End If

        wmiObj.Put_
        Exit For
    End If
Next

Set wmiObj = Nothing
Set wmiObjSet = Nothing
Set objWMIService = Nothing
```



很快，所有的打印机都可以保留打印文档了。



#### 行动四：监视打印队列，获取打印文档

1、先要初始化打印选项

```vb
' ****** 初始化打印选项 ******
With PrintOptions1
	.Version = 2 ' 固定设定为2
	.Count = 2 ' 作业信息和打印机信息

	' 获取需要的打印事件
  	With PrinterNotifyOptions(0)
		.Type = PRINTER_NOTIFY_TYPE
		ReDim pFieldsPrinter(0 To 19) As Integer
	
        pFieldsPrinter(0) = PRINTER_NOTIFY_FIELD_PRINTER_NAME
		pFieldsPrinter(1) = PRINTER_NOTIFY_FIELD_SHARE_NAME
		pFieldsPrinter(2) = PRINTER_NOTIFY_FIELD_STATUS
		.Count = (UBound(pFieldsPrinter) - LBound(pFieldsPrinter)) + 1
		.pFields = VarPtr(pFieldsPrinter(0))
  	End With

	' 获取需要的作业事件
	With PrinterNotifyOptions(1)
		.Type = JOB_NOTIFY_TYPE
		ReDim pFieldsJob(0 To 22) As Integer
		pFieldsJob(0) = JOB_NOTIFY_FIELD_PRINTER_NAME
		pFieldsJob(1) = JOB_NOTIFY_FIELD_MACHINE_NAME
		pFieldsJob(2) = JOB_NOTIFY_FIELD_PORT_NAME
		pFieldsJob(3) = JOB_NOTIFY_FIELD_USER_NAME
		pFieldsJob(4) = JOB_NOTIFY_FIELD_NOTIFY_NAME
		pFieldsJob(5) = JOB_NOTIFY_FIELD_DATATYPE
		pFieldsJob(6) = JOB_NOTIFY_FIELD_PRINT_PROCESSOR
		pFieldsJob(7) = JOB_NOTIFY_FIELD_PARAMETERS
		pFieldsJob(8) = JOB_NOTIFY_FIELD_DRIVER_NAME
		pFieldsJob(9) = JOB_NOTIFY_FIELD_DEVMODE
		pFieldsJob(10) = JOB_NOTIFY_FIELD_STATUS
		pFieldsJob(11) = JOB_NOTIFY_FIELD_STATUS_STRING
		pFieldsJob(12) = JOB_NOTIFY_FIELD_DOCUMENT
		pFieldsJob(13) = JOB_NOTIFY_FIELD_PRIORITY
		pFieldsJob(14) = JOB_NOTIFY_FIELD_POSITION
		pFieldsJob(15) = JOB_NOTIFY_FIELD_SUBMITTED
		pFieldsJob(16) = JOB_NOTIFY_FIELD_START_TIME
		pFieldsJob(17) = JOB_NOTIFY_FIELD_UNTIL_TIME
		pFieldsJob(18) = JOB_NOTIFY_FIELD_TIME
		pFieldsJob(19) = JOB_NOTIFY_FIELD_TOTAL_PAGES
		pFieldsJob(20) = JOB_NOTIFY_FIELD_PAGES_PRINTED
		pFieldsJob(21) = JOB_NOTIFY_FIELD_TOTAL_BYTES
		.Count = (UBound(pFieldsJob) - LBound(pFieldsJob)) + 1
		.pFields = VarPtr(pFieldsJob(0))
	End With

 	.lpPrintNotifyOptions = VarPtr(PrinterNotifyOptions(0))
End With
```



这里要用到一个函数：`WaitForSingleObject` 。

它的作用简单地说就是等待打印作业信号才返回继续后面的程序执行。



```vb
' ****** 设定内核等待打印事件信号 ******
Dim mhPrinter AS Long
Dim pDefault As PRINTER_DEFAULTS
With pDefault
	.pDatatype = vbNullString
	.pDevMode = 0
	.DesiredAccess = PRINTER_ACCESS_USE
End With

If mhPrinter <> 0 Then Call ClosePrinter(mhPrinter)

res = OpenPrinter("Microsoft Print to PDF", mhPrinter, pDefault)

Dim mEventHandle As Long
mEventHandle = FindFirstPrinterChangeNotificationLong(mhPrinter, 0, 0, VarPtr(PrintOptions))

' 无限期等待打印作业信号，程序会运行到这里停止，直到打印事件发生才会继续
Call WaitForSingleObject(mEventHandle, INFINITE)
```



```vb
' ****** 一旦有打印动作产生，则获取打印队列信息 ******
Dim lpPrintInfoBuffer As Long
Dim pdwChange As Long
Call FindNextPrinterChangeNotificationByLong(mEventHandle, pdwChange, PrintOptions1, lpPrintInfoBuffer)

Dim mData As PRINTER_NOTIFY_INFO
' mData包含一个有效的PRINTER_NOTIFY_INFO结构体'
Call CopyMemoryPRINTER_NOTIFY_INFO(mData, lpPrintInfoBuffer, Len(mData))

If mData.dwCount > 0 Then
	ReDim aData(1 To mData.dwCount) As PRINTER_NOTIFY_INFO_DATA
	Call CopyMemoryPRINTER_NOTIFY_INFO_DATA(aData(1), lpPrintInfoBuffer + Len(mData), Len(aData(1)) * mData.dwCount)
	'Debug.Print aData(1).Field
	'Debug.Print aData(1).id
	'Debug.Print aData(1).Type
	'Debug.Print aData(1).Reserved
	'Debug.Print aData(1).adwData(0)
	'Debug.Print aData(1).adwData(1)
	
    ' 在此可记录打印信息
    List1.AddItem strPrinterName & " | " & aData(1).Type & " - " & aData(1).Field
```



```vb
' ****** 如果打印结束，则获取打印文档并记录动作信息等 ******
' 1.获取打印信息
Dim booPrinted As Boolean, intCount As Integer
Do While (booPrinted = False)

	Set clsPrinterInfo = New CPrinterInfo
	clsPrinterInfo.DeviceName = strPrinterName '"Microsoft Print to PDF"

    Dim clsPrinterJobInfo As CPrinterJobInfo
	Dim strStatusText As String, strDatatype As String, strDocument As String, strMachineName As String, strNotifyName As String
	Dim strPagesPrinted As String, strTotalPages As String, strSize As String, strSubmitted As String, strPortName As String
	Dim strJobId As String, strTime As String
	Dim strSplFile As String, strExt As String 'SPL文件

	For Each clsPrinterJobInfo In clsPrinterInfo.Jobs
		
		With clsPrinterJobInfo
			strStatusText = .StatusText
			strDatatype = .StatusText
			strDocument = .Document
			strMachineName = .MachineName
			strNotifyName = .NotifyName
			strPagesPrinted = .PagesPrinted
			strTotalPages = .TotalPages
			strSize = FormatBytes(.Size)
			strSubmitted = CStr(clsPrinterJobInfo.Submitted)
			strPortName = clsPrinterInfo.PortName
			strJobId = CStr(.JobId)
			strTime = CStr(.Time)
		End With
		
		' 1.判断是否是printed状态
		If UCase(strStatusText) = "PRINTED" Then
			
			' 2.复制SPL文件
			Dim lngResult As Long, strSource As String, strTarget As String

			strExt = strJobId & ".SPL" '"69.SPL"
			strSplFile = findSplFile(strSpoolPath, strExt)
			strSource = strSpoolPath & "\" & strSplFile
			strTarget = strSplCopyTo & "\" & strSplFile

			lngResult = CopyFileEvenIfOpen(strSource, strTarget)

			If lngResult = 0 Then
				MsgBox "sccuess!"
			Else
				MsgBox "failed!"
			End If

			' 3.删除相应JobId的打印作业
			clsPrinterInfo.Jobs.ControlCancel strJobId
			clsPrinterInfo.Refresh

		End If

	Next
	
Loop
	
' 4.清空打印队列，释放缓存
Set clsPrinterJobInfo = Nothing
Set clsPrinterInfo = Nothing
Erase aData
Call FreePrinterNotifyInfoByLong(lpPrintInfoBuffer)
Call FindClosePrinterChangeNotification(mEventHandle)
```





#### 行动五：解析识别打印队列文档

SPL打印缓存文件到手了，接下来要正确打开它才能看到内容。

可是SPL文件有很多种格式，比如 `raw` 、 `emf` 或 `pcl` 等等，要怎样才能正确打开呢？



关于打印未公开的文档，网址：`http://www.undocprint.org/formats/winspool/spl` 。

其中有大量的文章和工具，叶冲选择了 [SPL Viewer](http://www.lvbprint.de/html/splviewer.htm) ，这个是免费的，好像最好用些。

图



还有一款收费软件 `O&K Printer Viewer` ，也可以随意查看 `SPL` 文件。

> O&K Printer Viewer 支持以下文件格式
>
> * PDF – Adobe Portable Document Format
> * EMF – Windows Metafile
> * BMP – Windows Bitmap
> * GIF – CompuServe GIF
> * PNG – Portable Network Graphics
> * TIFF – Tag Image File Format
> * JPG – JPEG



通常，SPL缓存打印文件格式都能被包括以上程序正常识别并打开。

如果格式是 `RAW` 的话，通常是由于虚拟打印产生的，比如打印成 `PDF` 文档等。

这时可能就不会被正确打开了，因为 `RAW` 格式是与特定设备相关的控制语言，可以理解为某台打印设备才能识别的一系列内容，不具备通用性。

可以通过转换为其他通用格式，但是由于时间紧，叶冲一时没有找到解决的办法。

但可以肯定的是，一般的物理打印设备产生的 `SPL` 文件99%是可以被程序识别打开的。







> WeChat @网管小贾 | Blog @www.sysadm.cc









