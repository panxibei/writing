如何手工打造一款公平的年会抽奖软件（二）

副标题：祝你年年中奖，天天好运~



上一篇说到，我得到了员工的嘱托和领导的信任，临危受命制作一款公平抽奖软件。

当时我就竖起手指敬了个礼，饱含热泪地接下了任务，带着这么多人的期盼，我得加把劲放手干不是吗！

OK，上一篇中程序的基本架子有了，那接下来就要进一步完善强化某些功能了。

（文末有安装包下载，免费分享给小伙伴儿们使用哦！）



#### 一、界面控件布局要美丽

抽奖是个高兴的事儿，即便没中奖人人也乐得参与，万一要中了呢，玩的就是个心跳。

既然大家高高兴兴的来，那就不能扫了大家的兴致，这抽奖界面的模样怎么也得打扮得好看点儿。

背景图片那自不用多说，来张大红的，特喜庆的那种。

虽然都是红的，但考虑到各人喜好不同，可以在程序目录中放上一张文件名为 `Background.jpg` 的图片文件作为自定义背景图片，程序启动自动加载哦。

你说你还要自己去找图片，麻烦不，我这就有啊！

好吧，我认识的小伙伴儿们有几个得了懒癌，都是我给惯的，那就再让我惯你们一次吧。

我也是从网上扯了几张图片，放在文末自行下载吧。



除了背景图这张脸，还有就是脸上的五官了。

为了更加方便地调整五官的位置，程序上开了个菜单，点击 `手动移动控件` 这一菜单项即可启用或禁用这项功能。

启用后就可以用鼠标拖动界面上的控件，嘿嘿，想放哪儿就放哪儿，爽不爽？

拖一次爽一次，一直拖一真爽，不过拖完了别忘记再点一次菜单项禁用拖拽功能。

图1



当然，我相信你们之中肯定隐藏着精致强迫症患者，好吧，那还可以用数字坐标来调整控件位置。

图2



#### 二、最简单有效的数字滚动效果

抽奖时要有动态效果，我们不搞复杂的，最简单的就是数字滚动了。

不用多说，这个等待摇奖停止的动态滚动过程才是最让人激动和期待的，完全有一种瞬间让人感觉生活还是有点儿盼头的哈。

具体怎么做，往下看！

先定义一个 `Timer` 控件，命名为 `tmrLuckDraw` ，然后随机生成11位数字，显示到标签 `lblCardID` 上。

当 `tmrLuckDraw.Interval = 1` 时即可触发滚动效果，这个数值越大，数字滚动得越慢。

```vb
' RndNumCardId 函数产生11位数字字符串
Dim strRndCircle As String
strRndCircle = RndNumCardId(999999999)
lblCardId.Caption = strRndCircle
lblCardId.Refresh
```

图3 gif动图



这里的数字滚动设定为11位的手机号码，当然这一项也可以改为员工的工号或其它可以唯一标识员工的字串。

如果需要修改成其它位数的字串，可以联系我定制，人民币是我大哥，他让我干啥我就干啥！



#### 三、用快捷按键控制抽奖的开始和停止



在主窗体的 `Load` 事件中定义相应的快捷按键。

开始抽奖为 `F11` 键，ID为1；暂停抽奖为 `空格` ，ID为2。

```
Dim ret As Long

'记录原来的window程序地址
preWinProc = GetWindowLong(Me.hwnd, GWL_WNDPROC)
'用自定义程序代替原来的window程序
ret = SetWindowLong(Me.hwnd, GWL_WNDPROC, AddressOf Wndproc)

'开始抽奖
idHotKey = 1 ' ID为1
Modifiers = 0 ' 组合键使用加号连接，此处为空（MOD_SHIFT，MOD_ALT，MOD_CONTROL）
uVirtKey = vbKeyF11 ' F11键
ret = RegisterHotKey(Me.hwnd, idHotKey, Modifiers, uVirtKey)

'暂停抽奖
idHotKey = 2 ' ID为2
Modifiers = 0 ' 组合键使用加号连接，此处为空（MOD_SHIFT，MOD_ALT，MOD_CONTROL）
uVirtKey = vbKeySpace ' 空格键
ret = RegisterHotKey(Me.hwnd, idHotKey, Modifiers, uVirtKey)
```



快捷按键的处理，通过以下 `Wndproc` 函数调用，通过前面定义的ID来判断按键。

```vb
Public Function Wndproc(ByVal hwnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    
    If Msg = WM_HOTKEY Then

		Select Case wParam
            Case 1
                ' 抽奖开始代码...
            Case 2
                ' 抽奖暂停代码...
        End Select
        
    End If
            
    '如果不是热键信息则调用原来的程序
    Wndproc = CallWindowProc(preWinProc, hwnd, Msg, wParam, lParam)
End Function
```





#### 四、抽奖过程中断了怎么办



一个简单的办法，就是在重新加载奖项时，先判断是否存在上一次的抽奖结果。

如果存在（比如抽奖剩余数大于1），则表示上一次抽奖过程中断，那么可以给出两种选择。

一种是继续上一次抽奖，另一种是重置上一次结果，开始新一轮的抽奖。

其实你仔细研究，就会发现，这两种选择其实有先后顺序，完全可以合并为一种。

那么就简单了，一旦抽奖过程遭遇中断，重启程序后自动上一次抽奖过程。

如果不想继续，那么完全可以从头来过。

```vb
objIteSql.p_Sql = "SELECT luckdraw FROM result_temp WHERE counts_rest > 0"
If objIteSql.SelectSQL = True Then
    If objIteSql.p_RecordCount > 0 Then
        '上次抽奖未结束，则自动导入剩余的奖项和计数
    End If
End If
```







#### 五、如何做到奖项任意抽取

一般情况下，抽奖总是按先低后高奖项的顺序抽取的。

但你是知道的，这仅仅是一般情况，世事无常，总会有特殊情况的嘛。

特殊情况是啥？

就是有人喜欢先抽三等奖，再抽五等奖，最后抽一等奖。

有这么奇葩吗？

哎，你还别说，这只是初级奇葩！

高级奇葩的需求是，先抽三等奖3名，再抽五等奖5名，最后抽一等奖1名。

噗~一口农夫山泉喷出，一点儿也不甜！



想想复杂，做起来...也没那么简单好不好？

WELL，我尽量做就是了。

放几个 `ComboBox` 下拉框，放几个文本框，分别用来显示奖项、剩余数量、已抽取数量和每次可抽取数量。

在开始每一次抽奖前，可自由选择奖项和抽取数量。

按下暂停按钮后，程序通过这些项目和数量来进一步判断和计算。

代码太多，就不放上来了。

图4



#### 六、抽奖结果怎么导出来呢

使用 `MSFlexGrid` 控件来填充结果数据。

这个控件是微软出品，比较原始，所以导出速度并不理想，但作为抽奖结果没几条数据，用用还算凑合。

以后需要改进的话，可以使用 `MSHFlexGrid` 或其它更高级的表格控件。

图5



```vb
Dim strSql As String
strSql = "SELECT a.cardid, a.luckdraw, a.datetimes, b.username, b.department FROM result AS A LEFT OUTER JOIN members AS B ON a.cardid=b.cardid"
    
msfgResult.Redraw = False
msfgResult.Tag = ""
Call fillGridScanlog(msfgResult, strSql)
msfgResult.Redraw = True

' MSFlexGrid 填充数据函数
Private Sub fillGridScanlog(grid As MSFlexGrid, Optional strSql As String)
    Dim strRowData As String, rowindex As Integer
    rowindex = 1
    
    With grid
        If Len(.Tag) = 0 Then
            .Rows = 1
            .Cols = 6
            .Row = 0
            .Col = 0
            .Text = "NO"
            .ColWidth(0) = 400
            .ColAlignment(0) = flexAlignCenterCenter
            .Col = 1
        	.Text = "编号"
            .ColWidth(1) = 1200
            .ColAlignment(1) = flexAlignLeftCenter
            .Col = 2
            .Text = "姓名"
            .ColWidth(2) = 1200
            .ColAlignment(2) = flexAlignLeftCenter
            .Col = 3
            .Text = "部门"
            .ColWidth(3) = 1500
            .ColAlignment(3) = flexAlignLeftCenter
            .Col = 4
            .Text = "奖项"
            .ColWidth(4) = 3000
            .ColAlignment(4) = flexAlignLeftCenter
            .Col = 5
            .Text = "时间"
            .ColWidth(5) = 2400
            .ColAlignment(5) = flexAlignLeftCenter
            
            
            Dim objIteSql As New cls_iteSql
            objIteSql.p_DbFilePath = strDbPath
            objIteSql.p_CheckSql = False
            objIteSql.p_Sql = strSql
            
            If objIteSql.SelectSQL = True Then
                Dim j As Long
                Dim intRecordCount As Long
                
                intRecordCount = objIteSql.p_RecordCount - 1
                
                For j = 0 To intRecordCount
                    strRowData = rowindex & vbTab
                    strRowData = strRowData & Trim(objIteSql.p_RecordSetValue(j, 0)) & vbTab
                    strRowData = strRowData & Trim(objIteSql.p_RecordSetValue(j, 3)) & vbTab
                    strRowData = strRowData & Trim(objIteSql.p_RecordSetValue(j, 4)) & vbTab
                    strRowData = strRowData & Trim(objIteSql.p_RecordSetValue(j, 1)) & vbTab
                    strRowData = strRowData & Trim(objIteSql.p_RecordSetValue(j, 2)) & vbTab
                    
                    .AddItem strRowData
                    rowindex = rowindex + 1
                Next
            End If
            Set objIteSql = Nothing
            .Tag = 1
        End If
    End With
End Sub
```



#### 七、公平抽奖真的公平吗

到最后了，差点忘了说说这个公平抽奖。

公司两千号人，怎么做到公平抽奖呢？

我用了史上最简单最单纯的算法，像洗牌一样，随机多洗几次。

说人话就是，把公司员工的手机号（或编号）排列成一维数组，然后从数组的第一位开始，将当前位的号码与其他随机位置的号码互换，直至最后一位。

这样就等于洗牌了嘛，当然，一次还不够，我设定最少洗10次，这样顺序就打得比较乱了。

然后实际抽奖时，随机从已经打乱顺序的数组中选取一个，那么就可以实现随机中奖了。

当然在这个过程中，已经中奖的人员事先会被剔除数组列中的。

```vb
' rstTmpdata 是人员数组，intShuffle 是洗牌次数
For intCC = 0 To intShuffle
	lngRecordCount = UBound(rstTmpdata) - 1

' 从头至尾，当前位置与随机位置互换
	For j = 0 To lngRecordCount
		intPos = RndNum(lngRecordCount + 1)

        rTpData = rstTmpdata(intPos)
        rstTmpdata(intPos) = rstTmpdata(lngRecordCount)
        rstTmpdata(lngRecordCount) = rTpData

        lngRecordCount = lngRecordCount - 1
    Next

Next
```



由于人员顺序是打乱的，抽取的时候也是在这打乱的基础上随机抽取的，所以说够公平了吧。

如果你觉得打得还不够乱不够随机，程序里你可以指定洗牌次数，不过最好不要洗太多，因为程序速度可能会受影响。

鉴于更公平的原则，洗牌和随机抽取都是在按下暂停时才开始计算的。

也就是说，在开始抽奖（数字开始滚动）时，并没有已经产生中奖者，够公平不？



#### 最后，免费下载、免费使用

程序经过多年的测试和实际使用，还是比较好用的。

在这儿免费分享给小伙伴儿们，未注册版限制10人。

***注册码免费获取，关注公众号@网管小贾，发送 `xjluckdraw` 免费获取，注册后没有任何使用限制了。***





免费下载链接（文章ID在二维码下方附近）：



背景图片打包下载：







上一篇链接：





WeChat@网管小贾 | www.sysadm.cc





