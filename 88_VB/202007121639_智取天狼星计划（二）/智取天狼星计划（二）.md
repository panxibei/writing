智取天狼星计划（二）

副标题：英雄虎胆施妙计，豪杰妙手赚名单



> 阅读前文：[《智取天狼星计划（一）》](https://www.sysadm.cc/index.php/vbbiancheng/756-take-sirius-plan-by-strategy-1)

叶冲在屋中来回踱步，思考着如何才能获取打印时产生的 `SPL` 文档。

如果通过传统的方法使用 `Timer` 控件循环监视打印作业的产生，似乎并不科学也不专业。

打印动作并非时刻都会有，况且如果打印作业时间较长，如何把握好开始和结束是个不太容易控制的问题。

万一打印过程中产生了延迟，程序必定会出错而失效，那么就会痛失获取文档的良机。

这可怎么办好？



外面渐渐传来了打更的声音，此时已经是半夜子时。

叶冲依然在屋中来回踱步，仍不得要领。

随着打更的声音越来越近，在这平静的夜晚显得格外响亮。

哎？叶冲先是一愣，随后慢慢露出了笑容，心中念道：“有了！”

每天晚上都有打更之人经过门前，而到了门前才能清晰地听到打更的声音。

只要等待系统产生打印动作信号，就可以及时获取打印状态和作业文档了！

终于想到了，太棒了！

叶冲此时有些兴奋，高兴地差点叫出声。

时间紧迫，赶快试一试吧！

很快，他总结出下面的内容。





#### 行动四：监视打印队列，获取打印文档

##### 1、先要初始化打印选项，后面会用到

```vb
' ****** 初始化打印选项 ******
With PrintOptions1
	.Version = 2 ' 固定设定为2
	.Count = 2 ' 作业信息和打印机信息

	' 获取需要的打印事件
  	With PrinterNotifyOptions(0)
		.Type = PRINTER_NOTIFY_TYPE
		ReDim pFieldsPrinter(0 To 19) As Integer
	
        pFieldsPrinter(0) = PRINTER_NOTIFY_FIELD_PRINTER_NAME
		pFieldsPrinter(1) = PRINTER_NOTIFY_FIELD_SHARE_NAME
		pFieldsPrinter(2) = PRINTER_NOTIFY_FIELD_STATUS
		.Count = (UBound(pFieldsPrinter) - LBound(pFieldsPrinter)) + 1
		.pFields = VarPtr(pFieldsPrinter(0))
  	End With

	' 获取需要的作业事件
	With PrinterNotifyOptions(1)
		.Type = JOB_NOTIFY_TYPE
		ReDim pFieldsJob(0 To 22) As Integer
		pFieldsJob(0) = JOB_NOTIFY_FIELD_PRINTER_NAME
		pFieldsJob(1) = JOB_NOTIFY_FIELD_MACHINE_NAME
		pFieldsJob(2) = JOB_NOTIFY_FIELD_PORT_NAME
		pFieldsJob(3) = JOB_NOTIFY_FIELD_USER_NAME
		pFieldsJob(4) = JOB_NOTIFY_FIELD_NOTIFY_NAME
		pFieldsJob(5) = JOB_NOTIFY_FIELD_DATATYPE
		pFieldsJob(6) = JOB_NOTIFY_FIELD_PRINT_PROCESSOR
		pFieldsJob(7) = JOB_NOTIFY_FIELD_PARAMETERS
		pFieldsJob(8) = JOB_NOTIFY_FIELD_DRIVER_NAME
		pFieldsJob(9) = JOB_NOTIFY_FIELD_DEVMODE
		pFieldsJob(10) = JOB_NOTIFY_FIELD_STATUS
		pFieldsJob(11) = JOB_NOTIFY_FIELD_STATUS_STRING
		pFieldsJob(12) = JOB_NOTIFY_FIELD_DOCUMENT
		pFieldsJob(13) = JOB_NOTIFY_FIELD_PRIORITY
		pFieldsJob(14) = JOB_NOTIFY_FIELD_POSITION
		pFieldsJob(15) = JOB_NOTIFY_FIELD_SUBMITTED
		pFieldsJob(16) = JOB_NOTIFY_FIELD_START_TIME
		pFieldsJob(17) = JOB_NOTIFY_FIELD_UNTIL_TIME
		pFieldsJob(18) = JOB_NOTIFY_FIELD_TIME
		pFieldsJob(19) = JOB_NOTIFY_FIELD_TOTAL_PAGES
		pFieldsJob(20) = JOB_NOTIFY_FIELD_PAGES_PRINTED
		pFieldsJob(21) = JOB_NOTIFY_FIELD_TOTAL_BYTES
		.Count = (UBound(pFieldsJob) - LBound(pFieldsJob)) + 1
		.pFields = VarPtr(pFieldsJob(0))
	End With

 	.lpPrintNotifyOptions = VarPtr(PrinterNotifyOptions(0))
End With
```



##### 2、告诉系统我需要等待打印信号，就像每天等待打更的声音一样。

这里要用到一个系统函数：`WaitForSingleObject` 。

它的作用简单地说就是等待打印作业信号出现，之后才继续后面的程序执行。



```vb
' ****** 设定内核等待打印事件信号 ******
Dim mhPrinter AS Long
Dim pDefault As PRINTER_DEFAULTS
With pDefault
	.pDatatype = vbNullString
	.pDevMode = 0
	.DesiredAccess = PRINTER_ACCESS_USE
End With

If mhPrinter <> 0 Then Call ClosePrinter(mhPrinter)

res = OpenPrinter("Microsoft Print to PDF", mhPrinter, pDefault)

Dim mEventHandle As Long
mEventHandle = FindFirstPrinterChangeNotificationLong(mhPrinter, 0, 0, VarPtr(PrintOptions))

' 无限期等待打印作业信号，程序会运行到这里停止，直到打印事件发生才会继续
Call WaitForSingleObject(mEventHandle, INFINITE)
```



##### 3、打印信号来了，那么就开始获取打印信息吧。

```vb
' ****** 一旦有打印动作产生，则获取打印队列信息 ******
Dim lpPrintInfoBuffer As Long
Dim pdwChange As Long
Call FindNextPrinterChangeNotificationByLong(mEventHandle, pdwChange, PrintOptions1, lpPrintInfoBuffer)

Dim mData As PRINTER_NOTIFY_INFO
' mData包含一个有效的PRINTER_NOTIFY_INFO结构体'
Call CopyMemoryPRINTER_NOTIFY_INFO(mData, lpPrintInfoBuffer, Len(mData))

If mData.dwCount > 0 Then
	ReDim aData(1 To mData.dwCount) As PRINTER_NOTIFY_INFO_DATA
	Call CopyMemoryPRINTER_NOTIFY_INFO_DATA(aData(1), lpPrintInfoBuffer + Len(mData), Len(aData(1)) * mData.dwCount)
	'Debug.Print aData(1).Field
	'Debug.Print aData(1).id
	'Debug.Print aData(1).Type
	'Debug.Print aData(1).Reserved
	'Debug.Print aData(1).adwData(0)
	'Debug.Print aData(1).adwData(1)
	
    ' 在此可记录打印信息
    List1.AddItem strPrinterName & " | " & aData(1).Type & " - " & aData(1).Field
```



```vb
' ****** 如果打印结束，则获取打印文档并记录动作信息等 ******
Dim booPrinted As Boolean, intCount As Integer
Do While (booPrinted = False)

	Set clsPrinterInfo = New CPrinterInfo
	clsPrinterInfo.DeviceName = strPrinterName '"Microsoft Print to PDF"

    Dim clsPrinterJobInfo As CPrinterJobInfo
	Dim strStatusText As String, strDatatype As String, strDocument As String, strMachineName As String, strNotifyName As String
	Dim strPagesPrinted As String, strTotalPages As String, strSize As String, strSubmitted As String, strPortName As String
	Dim strJobId As String, strTime As String
	Dim strSplFile As String, strExt As String 'SPL文件

	For Each clsPrinterJobInfo In clsPrinterInfo.Jobs
		
		With clsPrinterJobInfo
			strStatusText = .StatusText
			strDatatype = .StatusText
			strDocument = .Document
			strMachineName = .MachineName
			strNotifyName = .NotifyName
			strPagesPrinted = .PagesPrinted
			strTotalPages = .TotalPages
			strSize = FormatBytes(.Size)
			strSubmitted = CStr(clsPrinterJobInfo.Submitted)
			strPortName = clsPrinterInfo.PortName
			strJobId = CStr(.JobId)
			strTime = CStr(.Time)
		End With
		
		' 1.判断是否是printed状态
		If UCase(strStatusText) = "PRINTED" Then
			
			' 2.复制SPL文件
			Dim lngResult As Long, strSource As String, strTarget As String

			strExt = strJobId & ".SPL" '"69.SPL"
			strSplFile = findSplFile(strSpoolPath, strExt)
			strSource = strSpoolPath & "\" & strSplFile
			strTarget = strSplCopyTo & "\" & strSplFile

			lngResult = CopyFileEvenIfOpen(strSource, strTarget)

			If lngResult = 0 Then
				MsgBox "sccuess!"
			Else
				MsgBox "failed!"
			End If

			' 3.删除相应JobId的打印作业
			clsPrinterInfo.Jobs.ControlCancel strJobId
			clsPrinterInfo.Refresh

		End If

	Next
	
Loop
	
' 4.清空打印队列，释放缓存
Set clsPrinterJobInfo = Nothing
Set clsPrinterInfo = Nothing
Erase aData
Call FreePrinterNotifyInfoByLong(lpPrintInfoBuffer)
Call FindClosePrinterChangeNotification(mEventHandle)
```



```vb
' 使用API的CopyFile，则不管文件是否打开都可以成功复制文件。
Public Declare Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Long) As Long

    ' 复制文件自定义函数
Public Function CopyFileEvenIfOpen(SourceFile As String, DestFile As String) As Long
    Dim Result As Long
    If Len(Dir(SourceFile)) = 0 Then
        Result = 0
    Else
        Result = CopyFile(SourceFile, DestFile, False)
    End If
    CopyFileEvenIfOpen = Result
End Function
```



叶冲没想到监控打印如此复杂，花了他不少时间用于调试。

还好，最终还是成功地触发了打印信号状态，后续的处理也正常完成了。

虽然正常完成了，但是叶冲也考虑到，如果佐藤有多台打印机，那么仅仅靠单线程的代码是不可能完成多台监控的。

那么只有一种办法，没错，就是使用多线程。

> [《[三国赛马之VB多线程演示》](https://www.sysadm.cc/index.php/vbbiancheng/752-vb-horse-racing-multi-thread)



打印监控程序顺利获取到了 `SPL` 文件，并将其移动到了指定的文件夹内。

接下来要如何处理 `SPL` 文件呢？

叶冲试着双击这些文件，发现并不能直接打开。

他挠了挠头，继续埋头查找起了资料。



#### 行动五：解析识别打印队列文档

`SPL` 文件，学名叫做打印缓存文件，顾名思义它是用来告诉打印机如何打印内容的文件，所以一般情况下人是直接看不了的。

`SPL` 文件有很多种格式，例如 `raw` 、 `emf` 或 `pcl` 等等，既然无法直接查看，那要怎样才能正确打开呢？



也是老天保佑，叶冲偶然间查到了一个网站。

这个网站表面平淡无奇，既没有花里胡哨的图片，也没有引人入胜的视频，却只有一堆堆眼花缭乱、不知所云的文字。

谁曾想到，正是这些无聊的文字中，隐藏着关于打印未公开的秘密文档资料。

网址：`http://www.undocprint.org/formats/winspool/spl` 。

图1

网站中有大量的说明资料和工具，叶冲选择了一个叫 [SPL Viewer](http://www.lvbprint.de/html/splviewer.htm) 的工具，这是免费的，似乎比其它的要好用些。

图2



还有一款收费软件 `O&K Printer Viewer` ，也可以随意查看 `SPL` 文件，不过叶冲并没有尝试。

> O&K Printer Viewer 支持以下文件格式
>
> * PDF – Adobe Portable Document Format
> * EMF – Windows Metafile
> * BMP – Windows Bitmap
> * GIF – CompuServe GIF
> * PNG – Portable Network Graphics
> * TIFF – Tag Image File Format
> * JPG – JPEG



通常，SPL缓存打印文件格式都能被以上程序正常识别并打开。

但是也有例外，如果格式是 `RAW` 的话，可能就不会被正确打开了。

图3



`RAW` 格式的 `SPL` 文件通常是由于虚拟打印产生的，比如打印成 `PDF` 文档等。

因为 `RAW` 格式是与特定设备相关的控制语言，可以理解为某台打印设备才能识别的一系列内容，不具备通用性。

虽然可以通过转换为其他通用格式，但是由于时间紧，叶冲一时也没有找到完美的解决办法，似乎只有部分商用转换软件可以实现。

但可以肯定的是，一般的物理打印设备产生的 `SPL` 文件99%是可以被程序识别并打开的。

图4



离天亮还有不到2个小时，叶冲彻夜未眠，他不敢有任何怠慢，在总结整理了前面的经验教训后，制作了一个按预想基本可以完成任务的程序。

这个程序可以实现最多同时监控四台打印机的功能。

添加需要监控的打印机后，点击开始，之后如果有打印作业产生，程序会自动移动打印文件夹中的SPL文件至程序当前的spl目录中。

图5



叶冲拖着疲惫的身体，迅速打包收拾好了一切。

他心中充满了斗志，准备天亮后背水一战，然而，一切都会按照叶冲预想的顺利进行吗？

叶冲不敢多想，稍稍打了个盹后，收拾行装就迈出家门踏上了征途......





> WeChat @网管小贾 | Blog @www.sysadm.cc









